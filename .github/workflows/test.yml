# Reusable workflow for testing Smart Smoker v2 applications

name: Test Applications

on:
  workflow_call:
    inputs:
      apps:
        description: 'JSON array of apps to test (e.g., ["backend", "device-service", "frontend", "smoker", "TemperatureChart"])'
        type: string
        required: true
      ref:
        description: 'Git ref to checkout'
        type: string
        required: false
        default: 'master'
    outputs:
      test-results:
        description: 'Test results summary'
        value: ${{ jobs.collect-results.outputs.test-results }}

jobs:
  # Install dependencies once
  install:
    uses: ./.github/workflows/install.yml
    with:
      ref: ${{ inputs.ref }}
      artifact_name: 'test-workspace'

  # Test applications
  test:
    needs: install
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        app: ${{ fromJson(inputs.apps) }}
    
    steps:
      - name: Download workspace
        uses: actions/download-artifact@v4
        with:
          name: test-workspace
          path: .

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20.11.1'

      - name: Use npm 10
        run: npm i -g npm@10

      - name: Cache Node Modules
        uses: actions/cache@v4
        env:
          cache-name: cache-node-modules
        with:
          path: |
            node_modules
            */*/node_modules
          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-build-${{ env.cache-name }}-
            ${{ runner.os }}-build-
            ${{ runner.os }}-

      # Run tests with coverage - will fail if coverage thresholds not met
      - name: Test ${{ matrix.app }}
        id: test-step
        run: |
          case "${{ matrix.app }}" in
            "backend")
              npm run test:cov --prefix apps/backend -- --coverageReporters=json-summary --coverageReporters=lcov --coverageReporters=text --reporters=default --reporters=jest-junit --outputFile=test-results.xml 2>&1 | tee test-output.log
              ;;
            "device-service")
              npm run test:cov --prefix apps/device-service -- --coverageReporters=json-summary --coverageReporters=lcov --coverageReporters=text --reporters=default --reporters=jest-junit --outputFile=test-results.xml 2>&1 | tee test-output.log
              ;;
            "frontend")
              npm run test --prefix apps/frontend -- --watchAll=false --coverage --coverageReporters=json-summary --coverageReporters=lcov --coverageReporters=text --reporters=default --reporters=jest-junit --outputFile=test-results.xml 2>&1 | tee test-output.log
              ;;
            "smoker")
              npm run test --prefix apps/smoker -- --coverage --coverageReporters=json-summary --coverageReporters=lcov --coverageReporters=text --reporters=default --reporters=jest-junit --outputFile=test-results.xml 2>&1 | tee test-output.log
              ;;
            "TemperatureChart")
              npm run test:coverage --prefix packages/TemperatureChart -- --coverageReporters=json-summary --coverageReporters=lcov --coverageReporters=text --reporters=default --reporters=jest-junit --outputFile=test-results.xml 2>&1 | tee test-output.log
              ;;
            *)
              echo "Unknown app: ${{ matrix.app }}"
              exit 1
              ;;
          esac

      # Create test result status file
      - name: Create test status
        if: always()
        run: |
          if [ "${{ steps.test-step.outcome }}" = "success" ]; then
            echo "success" > test-status.txt
            echo "All tests passed and coverage thresholds met" > test-details.txt
          else
            echo "failure" > test-status.txt
            
            # Extract failed test information from output
            if [ -f "test-output.log" ]; then
              # Look for Jest failure patterns
              failed_tests=$(grep -E "(FAIL|✕|Failed:|Test Suites: .* failed)" test-output.log || echo "")
              coverage_failures=$(grep -E "(Coverage threshold|Jest: Coverage threshold)" test-output.log || echo "")
              
              if [ -n "$coverage_failures" ]; then
                echo "Tests passed but coverage thresholds not met" > test-details.txt
                echo "" >> test-details.txt
                echo "Coverage threshold failures:" >> test-details.txt
                echo "$coverage_failures" >> test-details.txt
              elif [ -n "$failed_tests" ]; then
                echo "Test failures detected" > test-details.txt
                echo "" >> test-details.txt
                echo "Failed tests:" >> test-details.txt
                
                # Extract specific test names that failed
                grep -E "✕|FAIL.*\.spec\.|FAIL.*\.test\." test-output.log | head -20 >> test-details.txt || echo "See logs for details" >> test-details.txt
              else
                echo "Test run failed - check logs for details" > test-details.txt
              fi
            else
              echo "Test run failed - no output log available" > test-details.txt
            fi
          fi

      # Upload coverage reports
      - name: Upload coverage reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-${{ matrix.app }}
          path: |
            coverage/
            apps/${{ matrix.app }}/coverage/
            packages/${{ matrix.app }}/coverage/
          retention-days: 1

      # Debug: Show what coverage files exist before upload
      - name: Debug coverage files
        if: always()
        run: |
          echo "=== DEBUG: Coverage files check for ${{ matrix.app }} ===" >&2
          echo "Current directory: $(pwd)" >&2
          echo "Looking for coverage files..." >&2
          
          if [ -d "coverage" ]; then
            echo "Found root coverage directory:" >&2
            find coverage -name "*.json" -o -name "*.info" 2>/dev/null | head -5 >&2
          else
            echo "No root coverage directory" >&2
          fi
          
          if [ -d "apps/${{ matrix.app }}/coverage" ]; then
            echo "Found apps/${{ matrix.app }}/coverage directory:" >&2
            find "apps/${{ matrix.app }}/coverage" -name "*.json" -o -name "*.info" 2>/dev/null | head -5 >&2
          else
            echo "No apps/${{ matrix.app }}/coverage directory" >&2
          fi
          
          if [ -d "packages/${{ matrix.app }}/coverage" ]; then
            echo "Found packages/${{ matrix.app }}/coverage directory:" >&2
            find "packages/${{ matrix.app }}/coverage" -name "*.json" -o -name "*.info" 2>/dev/null | head -5 >&2
          else
            echo "No packages/${{ matrix.app }}/coverage directory" >&2
          fi

      # Upload test status
      - name: Upload test status
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-status-${{ matrix.app }}
          path: |
            test-status.txt
            test-details.txt
            test-output.log
          retention-days: 1

      # Upload test results 
      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ matrix.app }}
          path: |
            apps/${{ matrix.app }}/test-results.xml
            apps/${{ matrix.app }}/junit.xml
            packages/${{ matrix.app }}/test-results.xml
            packages/${{ matrix.app }}/junit.xml
          retention-days: 1

  # Collect and summarize results
  collect-results:
    needs: test
    runs-on: ubuntu-latest
    if: always()
    outputs:
      test-results: ${{ steps.summary.outputs.test-results }}
    
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Create test summary
        id: summary
        run: |
          echo "Creating test results summary..."
          
          # Create summary output
          summary_file="test-summary.json"
          echo '{"apps": {}}' > $summary_file
          
          # Parse the input apps list and process each one
          apps_input='${{ inputs.apps }}'
          # Convert JSON array to bash array
          apps_array=$(echo $apps_input | jq -r '.[]')
          
          for app in $apps_array; do
            echo "Processing app: $app"
            
            # Check test status
            status_file="./artifacts/test-status-$app/test-status.txt"
            details_file="./artifacts/test-status-$app/test-details.txt"
            if [ -f "$status_file" ]; then
              test_status=$(cat "$status_file")
              if [ -f "$details_file" ]; then
                test_details=$(cat "$details_file")
              else
                test_details="No details available"
              fi
            else
              test_status="unknown"
              test_details="Status file not found"
            fi
            
            # Check if coverage exists
            coverage_dir="./artifacts/coverage-$app"
            if [ -d "$coverage_dir" ]; then
              # Try to find coverage summary
              if [ -f "$coverage_dir/coverage-summary.json" ]; then
                coverage=$(cat "$coverage_dir/coverage-summary.json")
              elif [ -f "$coverage_dir/lcov-report/index.html" ]; then
                coverage='{"total": {"lines": {"pct": "Available in HTML report"}}}'
              else
                coverage='{"total": {"lines": {"pct": "N/A"}}}'
              fi
            else
              coverage='{"total": {"lines": {"pct": "No coverage data"}}}'
            fi
            
            # Create app entry in summary
            jq --arg app "$app" --argjson cov "$coverage" --arg status "$test_status" --arg details "$test_details" \
               '.apps[$app] = {"coverage": $cov, "status": $status, "details": $details}' \
               $summary_file > temp.json && mv temp.json $summary_file
          done
          
          # Output the summary
          test_results=$(cat $summary_file)
          echo "test-results<<EOF" >> $GITHUB_OUTPUT
          echo "$test_results" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
      - name: Upload summary
        uses: actions/upload-artifact@v4
        with:
          name: test-summary
          path: test-summary.json
          retention-days: 1
