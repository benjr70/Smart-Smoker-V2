# Automated Development Deployment
# Deploys to dev-cloud environment and virtual-smoker device after nightly images are built
# Phase 3 Story 3 - Extended to include virtual smoker device deployment

name: Dev Deploy

on:
  workflow_run:
    workflows: ['Nightly Dev Build & Deploy']
    types:
      - completed
    branches:
      - master
  workflow_dispatch: # Manual trigger for testing

permissions:
  contents: read

concurrency:
  group: dev-deploy
  cancel-in-progress: true

jobs:
  deploy-dev-cloud:
    # Only run if nightly workflow succeeded (or manual trigger)
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'master') }}
    runs-on: [self-hosted, linux, proxmox]
    outputs:
      health_status: ${{ steps.health_check.outputs.health_status }}
      rollback_status: ${{ steps.rollback.outputs.rollback_status }}

    steps:
      - name: Pre-deploy runner cleanup
        run: |
          echo "Runner disk usage:"
          df -h /
          # Light cleanup on runner (it's not the bottleneck)
          docker system prune -f --filter "until=24h" || true

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set deployment variables
        id: vars
        run: |
          DEV_HOST="smoker-dev-cloud"
          DEPLOY_DIR="/opt/smart-smoker-dev"
          COMPOSE_FILE="cloud.docker-compose.yml"
          VERSION="nightly"

          echo "DEV_HOST=${DEV_HOST}" >> $GITHUB_ENV
          echo "DEPLOY_DIR=${DEPLOY_DIR}" >> $GITHUB_ENV
          echo "COMPOSE_FILE=${COMPOSE_FILE}" >> $GITHUB_ENV
          echo "VERSION=${VERSION}" >> $GITHUB_ENV

          echo "Deployment target: ${DEV_HOST}"
          echo "Deployment directory: ${DEPLOY_DIR}"
          echo "Version: ${VERSION}"

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan -H ${DEV_HOST} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Verify SSH connectivity
        run: |
          echo "Testing SSH connectivity to ${DEV_HOST}..."
          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 root@${DEV_HOST} "echo 'SSH connection successful'"
          if [ $? -ne 0 ]; then
            echo "âŒ SSH connection failed"
            exit 1
          fi
          echo "âœ… SSH connectivity verified"

      - name: URL-encode MongoDB password
        id: encode_password
        run: |
          ENCODED_PASSWORD=$(printf %s "${{ secrets.MONGO_APP_PASSWORD }}" | jq -sRr @uri)
          echo "ENCODED_MONGO_APP_PASSWORD=${ENCODED_PASSWORD}" >> $GITHUB_ENV

      - name: Pre-deployment backup
        run: |
          echo "Creating pre-deployment backup on ${DEV_HOST}..."
          ssh root@${DEV_HOST} bash << 'REMOTE_SCRIPT'
            set -e
            DEPLOY_DIR="${{ env.DEPLOY_DIR }}"
            COMPOSE_FILE="${{ env.COMPOSE_FILE }}"
            
            cd "${DEPLOY_DIR}" || { echo "âŒ Deployment directory not found: ${DEPLOY_DIR}"; exit 1; }
            
            # Create backup directory if it doesn't exist
            sudo mkdir -p /opt/smart-smoker-dev/backups/deployments
            
            # Run backup script
            if [ -f "./scripts/deployment-backup.sh" ]; then
              COMPOSE_FILE="${COMPOSE_FILE}" ./scripts/deployment-backup.sh
            else
              echo "âš ï¸  Backup script not found, creating minimal backup..."
              TIMESTAMP=$(date +%Y%m%d-%H%M%S)
              BACKUP_DIR="/opt/smart-smoker-dev/backups/deployments/backup-${TIMESTAMP}"
              mkdir -p "${BACKUP_DIR}"
              if [ -f "${COMPOSE_FILE}" ]; then
                cp "${COMPOSE_FILE}" "${BACKUP_DIR}/${COMPOSE_FILE}.backup"
              fi
              docker compose ps > "${BACKUP_DIR}/compose-state.txt" 2>/dev/null || true
              echo "${BACKUP_DIR}" > /opt/smart-smoker-dev/backups/deployments/last-deployment-backup.txt
            fi
            echo "âœ… Backup completed"
          REMOTE_SCRIPT
        env:
          DEV_HOST: ${{ env.DEV_HOST }}

      - name: Copy deployment files
        run: |
          echo "Copying deployment files to ${DEV_HOST}..."
          # Copy docker-compose file
          scp cloud.docker-compose.yml root@${DEV_HOST}:${DEPLOY_DIR}/${COMPOSE_FILE}
          # Create infra directory structure and copy MongoDB init scripts
          ssh root@${DEV_HOST} "mkdir -p ${DEPLOY_DIR}/infra/mongodb-init"
          scp -r infra/mongodb-init/* root@${DEV_HOST}:${DEPLOY_DIR}/infra/mongodb-init/
          echo "âœ… Deployment files copied"

      - name: Reset Tailscale Serve before deployment
        run: |
          echo "Resetting Tailscale Serve to free up ports..."
          ssh root@${DEV_HOST} "tailscale serve reset || true"
          echo "âœ… Tailscale Serve reset"
        env:
          DEV_HOST: ${{ env.DEV_HOST }}

      - name: Pre-deploy target cleanup
        run: |
          echo "Running aggressive cleanup on ${DEV_HOST} before deployment..."
          ssh root@${DEV_HOST} bash << 'REMOTE_SCRIPT'
            echo "=== DISK USAGE BEFORE CLEANUP ==="
            df -h /
            
            echo ""
            echo "=== DOCKER DISK USAGE ==="
            docker system df || true
            
            echo ""
            echo "=== RUNNING AGGRESSIVE CLEANUP ==="
            # Prune ALL unused images (not just dangling)
            docker image prune -af || true
            # Prune build cache
            docker builder prune -af || true
            # Prune stopped containers
            docker container prune -f || true
            # Prune unused networks
            docker network prune -f || true
            # Prune unused volumes (IMPORTANT: only anonymous/unused ones)
            docker volume prune -f || true
            
            echo ""
            echo "=== DISK USAGE AFTER CLEANUP ==="
            df -h /
            
            # Check if we have enough space (at least 2GB free)
            AVAIL_KB=$(df / | tail -1 | awk '{print $4}')
            AVAIL_MB=$((AVAIL_KB / 1024))
            echo "Available space: ${AVAIL_MB}MB"
            
            if [ "${AVAIL_MB}" -lt 2048 ]; then
              echo "âŒ ERROR: Less than 2GB available after cleanup!"
              echo "Manual intervention required."
              exit 1
            fi
            
            echo "âœ… Sufficient disk space available"
          REMOTE_SCRIPT
        env:
          DEV_HOST: ${{ env.DEV_HOST }}

      - name: Deploy to dev-cloud
        id: deploy
        run: |
          echo "Deploying to ${DEV_HOST}..."
          ssh root@${DEV_HOST} bash << 'REMOTE_SCRIPT'
            set -e
            DEPLOY_DIR="${{ env.DEPLOY_DIR }}"
            COMPOSE_FILE="${{ env.COMPOSE_FILE }}"
            VERSION="${{ env.VERSION }}"
            
            cd "${DEPLOY_DIR}" || { echo "âŒ Deployment directory not found: ${DEPLOY_DIR}"; exit 1; }
            
            export VERSION="${VERSION}"
            export VAPID_PRIVATE_KEY='${{ secrets.VAPID_PRIVATE_KEY }}'
            export VAPID_PUBLIC_KEY='${{ secrets.VAPID_PUBLIC_KEY }}'
            export MONGO_ROOT_USER=admin
            export MONGO_ROOT_PASSWORD='${{ secrets.MONGO_ROOT_PASSWORD }}'
            export MONGO_APP_PASSWORD='${{ secrets.MONGO_APP_PASSWORD }}'
            export ENCODED_MONGO_APP_PASSWORD='${{ env.ENCODED_MONGO_APP_PASSWORD }}'
            
            echo "Pulling Docker images with version: ${VERSION}..."
            docker compose -f "${COMPOSE_FILE}" pull
            
            echo "Stopping existing containers..."
            docker compose -f "${COMPOSE_FILE}" down || true
            
            echo "Starting containers..."
            docker compose -f "${COMPOSE_FILE}" up -d --force-recreate
            
            echo "âœ… Deployment initiated"
          REMOTE_SCRIPT
        env:
          DEV_HOST: ${{ env.DEV_HOST }}

      - name: Wait for services to start
        run: |
          echo "Waiting for services to initialize (60 seconds)..."
          sleep 60

      - name: Configure Tailscale Serve
        run: |
          echo "Configuring Tailscale Serve on ${DEV_HOST}..."
          ssh root@${DEV_HOST} bash << 'REMOTE_SCRIPT'
            set -e
            echo "Resetting existing Tailscale Serve configuration..."
            tailscale serve reset || true
            
            echo "Configuring Tailscale Serve for frontend (port 80 -> HTTPS 443)..."
            tailscale serve --bg 80
            
            echo "Configuring Tailscale Serve for backend (port 3001 -> HTTPS 8443)..."
            tailscale serve --bg --https=8443 3001
            
            echo "Current Tailscale Serve configuration:"
            tailscale serve status
            echo "âœ… Tailscale Serve configured"
          REMOTE_SCRIPT
        env:
          DEV_HOST: ${{ env.DEV_HOST }}

      - name: Verify deployment health
        id: health_check
        run: |
          echo "Running health checks on ${DEV_HOST}..."
          if ./scripts/deployment-health-check.sh ${DEV_HOST} 3; then
            echo "âœ… All health checks passed"
            echo "health_status=success" >> $GITHUB_OUTPUT
          else
            echo "âŒ Health checks failed"
            echo "health_status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
        continue-on-error: true

      - name: Rollback on failure
        if: steps.health_check.outcome == 'failure'
        id: rollback
        run: |
          echo "ðŸš¨ Deployment failed health check, initiating rollback..."
          ssh root@${DEV_HOST} bash << 'REMOTE_SCRIPT'
            set -e
            DEPLOY_DIR="${{ env.DEPLOY_DIR }}"
            COMPOSE_FILE="${{ env.COMPOSE_FILE }}"
            
            cd "${DEPLOY_DIR}" || { echo "âŒ Deployment directory not found: ${DEPLOY_DIR}"; exit 1; }
            
            if [ -f "./scripts/rollback.sh" ]; then
              COMPOSE_FILE="${COMPOSE_FILE}" ./scripts/rollback.sh
            else
              echo "âš ï¸  Rollback script not found, attempting manual rollback..."
              # Try to restore from backup
              BACKUP_FILE="/opt/smart-smoker-dev/backups/deployments/last-deployment-backup.txt"
              if [ -f "${BACKUP_FILE}" ]; then
                BACKUP_DIR=$(cat "${BACKUP_FILE}")
                if [ -f "${BACKUP_DIR}/${COMPOSE_FILE}.backup" ]; then
                  cp "${BACKUP_DIR}/${COMPOSE_FILE}.backup" "${COMPOSE_FILE}"
                  docker compose -f "${COMPOSE_FILE}" up -d --force-recreate
                fi
              fi
            fi
            
            echo "Waiting for rollback to complete (30 seconds)..."
            sleep 30
          REMOTE_SCRIPT

          # Verify rollback success
          echo "Verifying rollback..."
          if ./scripts/deployment-health-check.sh ${DEV_HOST} 1; then
            echo "âœ… Rollback successful, system restored"
            echo "rollback_status=success" >> $GITHUB_OUTPUT
          else
            echo "ðŸ’¥ Rollback failed - MANUAL INTERVENTION REQUIRED"
            echo "rollback_status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
        env:
          DEV_HOST: ${{ env.DEV_HOST }}

      # Discord notification moved to combined 'notify' job at the end

      - name: Post-deploy target cleanup
        if: always()
        run: |
          echo "Cleaning up target disk space after deployment..."
          ssh root@${DEV_HOST} bash << 'REMOTE_SCRIPT' || echo "Target cleanup had issues, continuing..."
            # Prune unused images
            docker image prune -af || true
            # Prune build cache
            docker builder prune -af || true
            # Prune stopped containers
            docker container prune -f || true
            # Prune unused volumes
            docker volume prune -f || true
            echo "Target disk usage after cleanup:"
            df -h /
          REMOTE_SCRIPT
        env:
          DEV_HOST: ${{ env.DEV_HOST }}

      - name: Post-deploy runner cleanup
        if: always()
        run: |
          echo "Cleaning up runner disk space after deployment..."
          docker system prune -af --filter "until=24h" || true
          docker builder prune -af || true
          echo "Runner disk usage after cleanup:"
          df -h / || true

  # Deploy to virtual smoker device after dev-cloud deployment succeeds
  deploy-virtual-smoker:
    needs: deploy-dev-cloud
    if: success()
    uses: ./.github/workflows/device-deploy.yml
    with:
      device_host: 'virtual-smoker'
      version: 'nightly'
      compose_file: 'virtual-smoker.docker-compose.yml'
      ssh_user: 'smoker'
      deploy_dir: '/opt/smoker-device'
      environment: 'dev'
      cloud_backend_url: 'https://smoker-dev-cloud.tail74646.ts.net:8443'
    secrets: inherit

  # Send combined notification for both deployments
  notify:
    needs: [deploy-dev-cloud, deploy-virtual-smoker]
    if: always()
    runs-on: [self-hosted, linux, proxmox]

    steps:
      - name: Send Discord notification
        run: |
          if [ -n "${{ secrets.DISCORD_WEBHOOK_URL }}" ]; then
            DEV_CLOUD_STATUS="${{ needs.deploy-dev-cloud.result }}"
            VIRTUAL_SMOKER_STATUS="${{ needs.deploy-virtual-smoker.result }}"
            
            # Determine overall status
            if [ "$DEV_CLOUD_STATUS" = "success" ] && [ "$VIRTUAL_SMOKER_STATUS" = "success" ]; then
              COLOR=3066993  # Green
              TITLE="Dev Deployment Success"
              DESCRIPTION="Both dev-cloud and virtual-smoker deployments completed successfully"
            elif [ "$DEV_CLOUD_STATUS" = "success" ] && [ "$VIRTUAL_SMOKER_STATUS" = "skipped" ]; then
              COLOR=16776960  # Yellow
              TITLE="Dev Deployment Partial"
              DESCRIPTION="Dev-cloud deployed successfully, virtual-smoker was skipped"
            else
              COLOR=15158332  # Red
              TITLE="Dev Deployment Failed"
              DESCRIPTION="One or more deployments failed"
            fi
            
            # Build fields array using jq
            WORKFLOW_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            FIELDS=$(jq -n \
              --arg dev_cloud "${DEV_CLOUD_STATUS}" \
              --arg virtual_smoker "${VIRTUAL_SMOKER_STATUS}" \
              --arg workflow_url "${WORKFLOW_URL}" \
              '[
                {"name": "Dev Cloud", "value": $dev_cloud, "inline": true},
                {"name": "Virtual Smoker", "value": $virtual_smoker, "inline": true},
                {"name": "Version", "value": "nightly", "inline": true},
                {"name": "Workflow Run", "value": $workflow_url, "inline": false}
              ]')
            
            # Build payload using jq
            PAYLOAD=$(jq -n \
              --arg title "${TITLE}" \
              --arg desc "${DESCRIPTION}" \
              --argjson color "${COLOR}" \
              --argjson fields "${FIELDS}" \
              --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
              '{embeds: [{title: $title, description: $desc, color: $color, fields: $fields, timestamp: $ts}]}')
            
            curl -X POST "${{ secrets.DISCORD_WEBHOOK_URL }}" \
              -H "Content-Type: application/json" \
              -d "${PAYLOAD}" || echo "Failed to send Discord notification (webhook may not be configured)"
          else
            echo "Discord webhook not configured, skipping notification"
          fi
