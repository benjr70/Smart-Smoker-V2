# Automated Development Deployment
# Deploys to dev-cloud environment after nightly images are built

name: Dev Deploy

on:
  workflow_run:
    workflows: ['Nightly Dev Build & Deploy']
    types:
      - completed
    branches:
      - master
  workflow_dispatch: # Manual trigger for testing

permissions:
  contents: read

concurrency:
  group: dev-deploy
  cancel-in-progress: true

jobs:
  deploy-dev:
    # Only run if nightly workflow succeeded (or manual trigger)
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'master') }}
    runs-on: [self-hosted, linux, proxmox]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set deployment variables
        id: vars
        run: |
          DEV_HOST="smoker-dev-cloud"
          DEPLOY_DIR="/opt/smart-smoker-dev"
          COMPOSE_FILE="cloud.docker-compose.yml"
          VERSION="nightly"

          echo "DEV_HOST=${DEV_HOST}" >> $GITHUB_ENV
          echo "DEPLOY_DIR=${DEPLOY_DIR}" >> $GITHUB_ENV
          echo "COMPOSE_FILE=${COMPOSE_FILE}" >> $GITHUB_ENV
          echo "VERSION=${VERSION}" >> $GITHUB_ENV

          echo "Deployment target: ${DEV_HOST}"
          echo "Deployment directory: ${DEPLOY_DIR}"
          echo "Version: ${VERSION}"

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan -H ${DEV_HOST} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Verify SSH connectivity
        run: |
          echo "Testing SSH connectivity to ${DEV_HOST}..."
          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 root@${DEV_HOST} "echo 'SSH connection successful'"
          if [ $? -ne 0 ]; then
            echo "âŒ SSH connection failed"
            exit 1
          fi
          echo "âœ… SSH connectivity verified"

      - name: URL-encode MongoDB password
        id: encode_password
        run: |
          ENCODED_PASSWORD=$(printf %s "${{ secrets.MONGO_APP_PASSWORD }}" | jq -sRr @uri)
          echo "ENCODED_MONGO_APP_PASSWORD=${ENCODED_PASSWORD}" >> $GITHUB_ENV

      - name: Pre-deployment backup
        run: |
          echo "Creating pre-deployment backup on ${DEV_HOST}..."
          ssh root@${DEV_HOST} bash << 'REMOTE_SCRIPT'
            set -e
            DEPLOY_DIR="${{ env.DEPLOY_DIR }}"
            COMPOSE_FILE="${{ env.COMPOSE_FILE }}"
            
            cd "${DEPLOY_DIR}" || { echo "âŒ Deployment directory not found: ${DEPLOY_DIR}"; exit 1; }
            
            # Create backup directory if it doesn't exist
            sudo mkdir -p /opt/smart-smoker-dev/backups/deployments
            
            # Run backup script
            if [ -f "./scripts/deployment-backup.sh" ]; then
              COMPOSE_FILE="${COMPOSE_FILE}" ./scripts/deployment-backup.sh
            else
              echo "âš ï¸  Backup script not found, creating minimal backup..."
              TIMESTAMP=$(date +%Y%m%d-%H%M%S)
              BACKUP_DIR="/opt/smart-smoker-dev/backups/deployments/backup-${TIMESTAMP}"
              mkdir -p "${BACKUP_DIR}"
              if [ -f "${COMPOSE_FILE}" ]; then
                cp "${COMPOSE_FILE}" "${BACKUP_DIR}/${COMPOSE_FILE}.backup"
              fi
              docker compose ps > "${BACKUP_DIR}/compose-state.txt" 2>/dev/null || true
              echo "${BACKUP_DIR}" > /opt/smart-smoker-dev/backups/deployments/last-deployment-backup.txt
            fi
            echo "âœ… Backup completed"
          REMOTE_SCRIPT
        env:
          DEV_HOST: ${{ env.DEV_HOST }}

      - name: Copy deployment files
        run: |
          echo "Copying deployment files to ${DEV_HOST}..."
          # Copy docker-compose file
          scp cloud.docker-compose.yml root@${DEV_HOST}:${DEPLOY_DIR}/${COMPOSE_FILE}
          # Create infra directory structure and copy MongoDB init scripts
          ssh root@${DEV_HOST} "mkdir -p ${DEPLOY_DIR}/infra/mongodb-init"
          scp -r infra/mongodb-init/* root@${DEV_HOST}:${DEPLOY_DIR}/infra/mongodb-init/
          echo "âœ… Deployment files copied"

      - name: Reset Tailscale Serve before deployment
        run: |
          echo "Resetting Tailscale Serve to free up ports..."
          ssh root@${DEV_HOST} "tailscale serve reset || true"
          echo "âœ… Tailscale Serve reset"
        env:
          DEV_HOST: ${{ env.DEV_HOST }}

      - name: Deploy to dev-cloud
        id: deploy
        run: |
          echo "Deploying to ${DEV_HOST}..."
          ssh root@${DEV_HOST} bash << 'REMOTE_SCRIPT'
            set -e
            DEPLOY_DIR="${{ env.DEPLOY_DIR }}"
            COMPOSE_FILE="${{ env.COMPOSE_FILE }}"
            VERSION="${{ env.VERSION }}"
            
            cd "${DEPLOY_DIR}" || { echo "âŒ Deployment directory not found: ${DEPLOY_DIR}"; exit 1; }
            
            export VERSION="${VERSION}"
            export VAPID_PRIVATE_KEY='${{ secrets.VAPID_PRIVATE_KEY }}'
            export VAPID_PUBLIC_KEY='${{ secrets.VAPID_PUBLIC_KEY }}'
            export MONGO_ROOT_USER=admin
            export MONGO_ROOT_PASSWORD='${{ secrets.MONGO_ROOT_PASSWORD }}'
            export MONGO_APP_PASSWORD='${{ secrets.MONGO_APP_PASSWORD }}'
            export ENCODED_MONGO_APP_PASSWORD='${{ env.ENCODED_MONGO_APP_PASSWORD }}'
            
            echo "Pulling Docker images with version: ${VERSION}..."
            docker compose -f "${COMPOSE_FILE}" pull
            
            echo "Stopping existing containers..."
            docker compose -f "${COMPOSE_FILE}" down || true
            
            echo "Cleaning up old Docker resources..."
            # Prune unused images (not volumes - those contain persistent data)
            docker image prune -af || true
            # Prune unused build cache
            docker builder prune -af || true
            # Prune stopped containers
            docker container prune -f || true
            # Show disk space after cleanup
            echo "Disk usage after cleanup:"
            df -h /var/lib/docker || df -h /
            
            echo "Starting containers..."
            docker compose -f "${COMPOSE_FILE}" up -d --force-recreate
            
            echo "âœ… Deployment initiated"
          REMOTE_SCRIPT
        env:
          DEV_HOST: ${{ env.DEV_HOST }}

      - name: Wait for services to start
        run: |
          echo "Waiting for services to initialize (60 seconds)..."
          sleep 60

      - name: Configure Tailscale Serve
        run: |
          echo "Configuring Tailscale Serve on ${DEV_HOST}..."
          ssh root@${DEV_HOST} bash << 'REMOTE_SCRIPT'
            set -e
            echo "Resetting existing Tailscale Serve configuration..."
            tailscale serve reset || true
            
            echo "Configuring Tailscale Serve for frontend (port 80 -> HTTPS 443)..."
            tailscale serve --bg 80
            
            echo "Configuring Tailscale Serve for backend (port 3001 -> HTTPS 8443)..."
            tailscale serve --bg --https=8443 3001
            
            echo "Current Tailscale Serve configuration:"
            tailscale serve status
            echo "âœ… Tailscale Serve configured"
          REMOTE_SCRIPT
        env:
          DEV_HOST: ${{ env.DEV_HOST }}

      - name: Verify deployment health
        id: health_check
        run: |
          echo "Running health checks on ${DEV_HOST}..."
          if ./scripts/deployment-health-check.sh ${DEV_HOST} 3; then
            echo "âœ… All health checks passed"
            echo "health_status=success" >> $GITHUB_OUTPUT
          else
            echo "âŒ Health checks failed"
            echo "health_status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
        continue-on-error: true

      - name: Rollback on failure
        if: steps.health_check.outcome == 'failure'
        id: rollback
        run: |
          echo "ðŸš¨ Deployment failed health check, initiating rollback..."
          ssh root@${DEV_HOST} bash << 'REMOTE_SCRIPT'
            set -e
            DEPLOY_DIR="${{ env.DEPLOY_DIR }}"
            COMPOSE_FILE="${{ env.COMPOSE_FILE }}"
            
            cd "${DEPLOY_DIR}" || { echo "âŒ Deployment directory not found: ${DEPLOY_DIR}"; exit 1; }
            
            if [ -f "./scripts/rollback.sh" ]; then
              COMPOSE_FILE="${COMPOSE_FILE}" ./scripts/rollback.sh
            else
              echo "âš ï¸  Rollback script not found, attempting manual rollback..."
              # Try to restore from backup
              BACKUP_FILE="/opt/smart-smoker-dev/backups/deployments/last-deployment-backup.txt"
              if [ -f "${BACKUP_FILE}" ]; then
                BACKUP_DIR=$(cat "${BACKUP_FILE}")
                if [ -f "${BACKUP_DIR}/${COMPOSE_FILE}.backup" ]; then
                  cp "${BACKUP_DIR}/${COMPOSE_FILE}.backup" "${COMPOSE_FILE}"
                  docker compose -f "${COMPOSE_FILE}" up -d --force-recreate
                fi
              fi
            fi
            
            echo "Waiting for rollback to complete (30 seconds)..."
            sleep 30
          REMOTE_SCRIPT

          # Verify rollback success
          echo "Verifying rollback..."
          if ./scripts/deployment-health-check.sh ${DEV_HOST} 1; then
            echo "âœ… Rollback successful, system restored"
            echo "rollback_status=success" >> $GITHUB_OUTPUT
          else
            echo "ðŸ’¥ Rollback failed - MANUAL INTERVENTION REQUIRED"
            echo "rollback_status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
        env:
          DEV_HOST: ${{ env.DEV_HOST }}

      - name: Send Discord notification
        if: always()
        run: |
          if [ -n "${{ secrets.DISCORD_WEBHOOK_URL }}" ]; then
            STATUS="${{ job.status }}"
            HEALTH_STATUS="${{ steps.health_check.outputs.health_status || 'N/A' }}"
            ROLLBACK_STATUS="${{ steps.rollback.outputs.rollback_status || '' }}"
            
            if [ "$STATUS" = "success" ]; then
              COLOR=3066993  # Green
              TITLE="Dev Deployment Success"
              DESCRIPTION="Deployment to dev-cloud completed successfully"
            else
              COLOR=15158332  # Red
              TITLE="Dev Deployment Failed"
              DESCRIPTION="Deployment to dev-cloud failed"
            fi
            
            # Build fields array using jq
            WORKFLOW_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            FIELDS=$(jq -n \
              --arg status "${STATUS}" \
              --arg health "${HEALTH_STATUS}" \
              --arg workflow_url "${WORKFLOW_URL}" \
              '[
                {"name": "Environment", "value": "dev-cloud (smoker-dev-cloud)", "inline": true},
                {"name": "Version", "value": "nightly", "inline": true},
                {"name": "Status", "value": $status, "inline": true},
                {"name": "Health Check", "value": $health, "inline": true},
                {"name": "Workflow Run", "value": $workflow_url, "inline": false}
              ]')
            
            # Add rollback field if present
            if [ -n "${ROLLBACK_STATUS}" ]; then
              FIELDS=$(echo "${FIELDS}" | jq --arg rollback "${ROLLBACK_STATUS}" \
                '. + [{"name": "Rollback", "value": $rollback, "inline": true}]')
            fi
            
            # Build payload using jq
            PAYLOAD=$(jq -n \
              --arg title "${TITLE}" \
              --arg desc "${DESCRIPTION}" \
              --argjson color "${COLOR}" \
              --argjson fields "${FIELDS}" \
              --arg ts "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
              '{embeds: [{title: $title, description: $desc, color: $color, fields: $fields, timestamp: $ts}]}')
            
            curl -X POST "${{ secrets.DISCORD_WEBHOOK_URL }}" \
              -H "Content-Type: application/json" \
              -d "${PAYLOAD}" || echo "Failed to send Discord notification (webhook may not be configured)"
          else
            echo "Discord webhook not configured, skipping notification"
          fi
